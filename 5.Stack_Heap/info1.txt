1) Memory Management in Java

In Java, memory is mainly divided into two categories:

Stack Memory (for execution and method calls)

Heap Memory (for objects and instance data)

ðŸ‘‰ Java doesnâ€™t let you manually manage memory (like C/C++). Instead:

JVM + Garbage Collector (GC) handle allocation & deallocation.

Developers just need to know what goes where.

2) Stack

What it is:

A memory area used for method execution.

Follows LIFO (Last In, First Out) principle.

What is stored in stack:

Method call frames (a.k.a. activation records).

Local variables (declared inside a method).

Reference variables (holding addresses of heap objects).

Return addresses, partial results.

Lifecycle:

Created when method is invoked.

Destroyed automatically once method execution finishes.

Thread-specific:

Every thread in Java has its own stack â†’ no interference between threads.

3) Heap

What it is:

A memory area where objects and instance variables live.

Shared among all threads of the JVM.

What is stored in heap:

Objects created using new.

Instance variables (inside those objects).

Lifecycle:

Objects remain in heap until they are garbage collected (no references pointing to them).

Managed by GC:

JVMâ€™s Garbage Collector reclaims unused heap memory automatically.

4) Where Variables Are Allocated?

Letâ€™s use your Student example:

class Student {
    int instVariable; // instance variable â†’ stored in heap (inside object)

    public static void main(String[] args) {
        int localVariable = 0;        // stored in stack (method's stack frame)
        Student st = new Student();   // 'st' is reference variable â†’ in stack
                                      // new Student() â†’ object in heap
    }

    public int add(int num1, int num2) {
        // num1, num2 â†’ local variables (stack frame of add())
        return num1 + num2;
    }
}

Breakdown:

Instance Variable (instVariable)
â†’ Belongs to object â†’ object created in heap.

Local Variable (localVariable, num1, num2)
â†’ Lives inside stack frame of the method â†’ in stack.

Reference Variable (st)
â†’ The reference itself is in stack (inside main frame).
â†’ But it points to the actual object in heap.

Methods

Method code (definition) lives in Method Area / Class Area (not stack/heap).

Method execution (stack frame + local vars) lives in stack.

Interview-Friendly Summary ðŸŒŸ

Stack: Method calls, local variables, references â†’ thread-specific.

Heap: Objects + instance variables â†’ shared by all threads.

Reference variable: Lives in stack, points to object in heap.

Garbage Collector: Frees unused heap memory, not stack.

Static variables & method definitions: Stored in Method Area (a part of JVM memory model).

âœ… Key Trick for Interviews:
When asked "Where is X stored?" â†’

If local var â†’ Stack.

If instance var â†’ Heap (inside object).

If reference var â†’ Stack, but object in Heap.

If static var/methods â†’ Method Area (Class Area).

Key Rule of Thumb

Local variables + references â†’ Stack

Objects + instance variables â†’ Heap

Static variables + method bytecode â†’ Method Area